// Author: Kouek Kou

#include "/Engine/Public/Platform.ush"

#include "./GeoMath.ush"
#include "./Util.ush"

int MaxStepCnt;
float Step;
float RelativeLightness;
float2 RenderSize;
float2 LonRng;
float2 LatRng;
float2 HeightRng;
float4x4 EyeToEarth;
float4x4 InvProj;
SamplerState VolSamplerState;
SamplerState TFSamplerState;
Texture3D<float> VolInput;
Texture2D<float4> TFInput;
Texture2D<float> DepthInput;
RWTexture2D<float4> ColorOutput;

void TransformBLHToSamplePos(
    inout float3 BLHInSamplePosOut, inout float3 BLHMin,
    in float3 BLHInvDlt, in float2 heightToCntrRngEarthLong) {
    float2 realheightToCntrRng = float2(HeightToCenter(heightToCntrRngEarthLong[0], BLHInSamplePosOut.y),
                    HeightToCenter(heightToCntrRngEarthLong[1], BLHInSamplePosOut.y));
    BLHMin.z = realheightToCntrRng[0];
    BLHInvDlt.z = 1.f / (realheightToCntrRng[1] - realheightToCntrRng[0]);
    BLHInSamplePosOut = (BLHInSamplePosOut - BLHMin) * BLHInvDlt;
}

[numthreads(THREAD_PER_GROUP_X, THREAD_PER_GROUP_Y, THREAD_PER_GROUP_Z)]
void DVR(int3 dispatchThreadID : SV_DispatchThreadID) {
    if (dispatchThreadID.x >= RenderSize.x || dispatchThreadID.y >= RenderSize.y)
        return;
    
    const float2 heightToCntrRngEarthLong = FloatScale * HeightRng + float2(EarthLong, EarthLong);
    //float depth = DepthInput[dispatchThreadID.xy];
    //ColorOutput[dispatchThreadID.xy] = float4(depth, depth, depth, 1.f);

    Ray ray;
    {
        float4 tmp = float4(
            +(2.f * dispatchThreadID.x + 1.f - RenderSize.x) / RenderSize.x,
            -(2.f * dispatchThreadID.y + 1.f - RenderSize.y) / RenderSize.y,
            1.f, 1.f);
        tmp = mul(tmp, InvProj);
        tmp.w = 0.f;
        tmp = mul(tmp, EyeToEarth);
        
        ray.dir = normalize(tmp.xyz);
        ray.origin = FloatScale * EyeToEarth._m30_m31_m32;
    }
    
    float step = FloatScale * Step;
    float a = 0.f;
    float3 rgb = float3(0.f, 0.f, 0.f);
    float3 posDlt = step * ray.dir;
    float3 BLHMin = float3(LonRng[0], LatRng[0], -1.f);
    float3 BLHInvDlt = 1.f / float3(LonRng[1] - LonRng[0], LatRng[1] - LatRng[0], -1.f);
    float4 tRng = IntersectEarthShell(heightToCntrRngEarthLong, ray);
    int stepCnt = 0;
    [unroll(2)]
    for (int start = 0; start <= 2; start += 2) {
        if (tRng[start] < 0.f)
            continue;
        
        tRng[start] = floor(tRng[start] / step) * step;
        tRng[start + 1] = ceil(tRng[start + 1] / step) * step;
        
        float3 pos;
        {
            float3 BLH;
            int outRngFlag = 0;
            pos = ray.origin + tRng[start + 1] * ray.dir;
            BLH = ECEFToBLH(pos);
            if (BLH.x < LonRng[0])
                outRngFlag |= (1 << 0);
            if (BLH.x > LonRng[1])
                outRngFlag |= (1 << 1);
            if (BLH.y < LatRng[0])
                outRngFlag |= (1 << 2);
            if (BLH.y > LatRng[1])
                outRngFlag |= (1 << 3);
        
            pos = ray.origin + tRng[start] * ray.dir;
            BLH = ECEFToBLH(pos);
            if (BLH.x < LonRng[0] &&
            (outRngFlag & (1 << 0)) != 0)
                continue;
            if (BLH.x > LonRng[1] &&
            (outRngFlag & (1 << 1)) != 0)
                continue;
            if (BLH.y < LatRng[0] &&
            (outRngFlag & (1 << 2)) != 0)
                continue;
            if (BLH.y > LatRng[1] &&
            (outRngFlag & (1 << 3)) != 0)
                continue;
        }

        float t = tRng[start];
        float tInvDlt = 1.f / (tRng[start + 1] - tRng[start]);

        int enterRng = 0;
        while (stepCnt <= MaxStepCnt && t <= tRng[start + 1]) {
            float3 samplePos = ECEFToBLH(pos);
            TransformBLHToSamplePos(samplePos, BLHMin, BLHInvDlt, heightToCntrRngEarthLong);

            if (all(samplePos >= float3(0.f, 0.f, 0.f)) && all(samplePos <= float3(1.f, 1.f, 1.f))) {
                ++enterRng;
                
                float scalar = VolInput.SampleLevel(VolSamplerState, samplePos, 0);
                float4 color = TFInput.SampleLevel(TFSamplerState, float2(scalar, .5f), 0);
                color.a *= RelativeLightness;

                rgb = rgb + (1.f - a) * color.a * color.rgb;
                a = a + (1.f - a) * color.a;
                if (a >= .95f)
                    break;
            }
            else if (enterRng != 0) // Leave the range after entered the range, braek
                break;
            
            pos += posDlt;
            t += step;
            ++stepCnt;
        }
    }
    //GammaCorrect(rgb);

    float4 prevCol = ColorOutput[dispatchThreadID.xy];
    ColorOutput[dispatchThreadID.xy].rgb = (1.f - a) * prevCol.rgb + a * rgb;
}
